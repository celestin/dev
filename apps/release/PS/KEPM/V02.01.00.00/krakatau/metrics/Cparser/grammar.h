/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Krakatau C/C++ Parser (CPARSER.EXE)
 * Copyright (c) 2000,2008 Power Software
 * Author Craig McKay <craig@frontburner.co.uk>
 *
 * $Id$
 *
 * Who  When       Why
 * CAM  27-Mar-08  345 : File added to source control.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

int look_semicolon();
void parse_sawn_off_declarator();
int inclusive_type_specifier_seq();
int func_parameter_declaration_clause();
void parse_extra_decl_spec();
int func_type_specifier();
int get_struct();
int get_union();
int get_private();
int get_protected();
int get_public();
int func_declarator();
int func_direct_declarator();
int qualified_namespace_specifier();
int namespace_alias_definition();
int explicit_specialization();
int namespace_body();
int get_extern();
int named_namespace_definition();
int unnamed_namespace_definition();
int original_namespace_definition();
int extension_namespace_definition();
int original_namespace_name();
void declaration_seq_opt();
int explicit_instantiation();
int linkage_specification();
void member_decl_specifier_seq_opt();
int member_decl_specifier_seq();
int get_typename();
int elaborated_type_specifier();
int template_argument_list();
int type_parameter();
int template_parameter_list();
int template_argument();
void export_opt();
int get_template();
int get_using();
void typename_opt();
int get_namespace();
int namespace_name();
int zero();
void pure_specifier_opt();
int using_declaration();
int template_declaration();
int function_definition();
void semicolon_opt();
int get_else();
int get_switch();
int get_if();
int get_throw();
int get_try();
int handler_seq();
int handler();
int k_and_r_parameter_declaration_clause();
int get_catch();
int get_for();
int get_break();
int get_continue();
int get_return();
int get_goto();
void statement_seq_opt();
int statement();
int get_case();
int get_default();
void expression_opt();
int semicolon();
int get_while();
int get_do();
void condition_opt();
int try_block();
int function_try_block();
int function_body();
void ctor_initializer_opt();
int mem_initializer_opt();
int mem_initializer();
int mem_initializer_id();
int selection_statement();
int try_block();
int mem_initializer_list();
void declarator_opt();
int direct_declarator();
int parenthesised_declarator();
int abstract_declarator();
int parenthesised_abstract_declarator();
int direct_abstract_declarator();
int yylex(void);
void new_initializer_opt();
void expression_list_opt();
int pseudo_destructor_name();
void new_declarator_opt();
int template_name();
int get_operator();
int conversion_type_id();
int sbs();
int throw_expression();
void abstract_declarator_opt();
void assignment_expression_opt();
int operator_function_id();
int conversion_function_id();
int template_id();
void template_opt();
int type_specifier_seq();
void template_opt();
void sym_name(int,int);
void intialise();
void advance();
void unadvance();
int the_end();
void panic(int);
int next_semicolon();
int asm_definition();
int storage_class_specifier();
void identifier_opt();
int comma();
void comma_opt();
int open_curly();
int close_curly();
int equals();
int enumerator();
int enumarator_definition();
void enumerator_list_opt();
int enum_specifier();
void scope_opt();
int nested_name_specifier();
void nested_name_specifier_opt();
int type_name();
int simple_type_specifier();
int class_key();
int identifier();
int colon();
int access_specifier();
void accss_specifier_opt();
int get_virtual();
void virtual_opt();
int class_name();
int base_specifier();
int base_specifier_list();
int base_clause();
void base_clause_opt();
int class_head();
void member_specification_opt();
int class_specifier();
int type_specifier();
int x_typedef();
int x_friend();
int function_specifier();
int decl_specifier();
int decl_specifier_seq();
void decl_specifier_seq_opt();
void init_declarator_list_opt();
int simple_declaration();
int block_declaration();
int declaration();
int cv_qualifier();
void cv_qualifier_seq_opt();
int ptr_operator();
int get_ob();
int ob_ptr_thing();
int primary_expression();
int id_expression(int);
int unqualified_id();
int qualified_id();
int postfix_expression();
int expression_list();
int psuedo_destructor_name();
int unary_expression();
int unary_operator();
int new_expression();
int new_placement();
int new_type_id();
int new_declarator();
int d_n_d_2();
void d_n_d_2_list_opt();
int direct_new_declarator();
int new_initializer();
int delete_expression();
int cast_expression();
int pm_expression();
int multiplicative_expression ();
int additive_expression ();
int shift_expression ();
int relational_expression();
int equality_expression();
int and_expression();
int exclusive_or_expression();
int inclusive_or_expression();
int logical_and_expression();
int logical_or_expression();
int conditional_expression();
int assignment_expression();
int assignment_operator();
int expression();
int constant_expression();
int decl_id();
int close_parenth();
int ellipsis();
int parameter_declaration();
int parameter_declaration_clause();
void exception_specification_opt();
int decl_param_part();
int get_osb();
int get_csb();
void constant_expression_opt();
int decl_const_part();
int declarator();
int initializer_list();
void initializer_list_opt();
int initializer_clause();
int initializer();
void initializer_opt();
int init_declarator();
int init_declarator_list();
void declaration_seq();

